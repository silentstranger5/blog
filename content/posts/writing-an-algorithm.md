+++
date = '2025-01-24T19:02:29+03:00'
draft = false
title = 'Writing an Algorithm'
+++

## Implementing SHA256 from scratch

In the last post, we used the [OpenSSL](https://openssl.org) library to implement the SHA256 message digest algorithm. There may be some cases, however, when you don't want to use a library. For example:

Notice that we are only using one part of the library's vast functionality once. We probably won't use it for other purposes in the future, not right now, at least. In this case, the overhead of building the entire library might not be worth it.
- Maybe you want to learn how to implement this algorithm yourself. In this case, you can get more insight and experience from implementing it rather than using a ready library.

Implementing the SHA256 algorithm from scratch sounds like quite a daunting task. It's difficult to think about where to even start. However, such an algorithm is probably widely used and implemented in a variety of languages and platforms. Surely, there has to be *something* about it somewhere.

It turns out that the SHA algorithm family is a part of FIPS (Federal Information Processing Standard). This means that this algorithm is not only properly described and standardized, but also such documentation is [openly available](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf). Take a look at this document. It is a bit technical, but it is not large, and it is particularly complicated. Let's walk through it and write our code as we go.

## Constants and definitions

As always, create some directory and create a new source file (maybe called `sha.c` or however you like to call it).

Before we proceed, let's include useful headers from the standard library:

```c
#include <stdio.h>  // standard input/output
#include <stdint.h> // standard integer types
#include <stdlib.h> // useful functions
#include <string.h> // string processing
```

Now let's read about SHA algorithms:

```
1. INTRODUCTION

Each algorithm can be described in two stages: preprocessing and hash computation. 
Preprocessing involves padding a message, parsing the padded message into m-bit blocks, and 
setting initialization values to be used in the hash computation. The hash computation generates 
a message schedule from the padded message and uses that schedule, along with functions, 
constants, and word operations to iteratively generate a series of hash values. The final hash 
value generated by the hash computation is used to determine the message digest.

Algorithm   Message Size    Block Size  Word Size   Message Digest Size
(bits)      (bits)          (bits)      (bits)      (bits)
SHA-256     < 2 ^ 64        512         32          256
```

Right away, we can set up some constants:

```c
#define w  32 // word   size in bits
#define ds 256 // digest size in bits
#define m  512 // block  size in bits
```

Now, there are some characters, operations, notations and terminology. You can read it since this can be useful in the future. Here are the functions that will be used in the algorithm:

```
3.2 Operations on Words

ROTL n(x) = (x << n) ∨ (x >> w - n)
ROTR n(x) = (x >> n) ∨ (x << w - n)

4.1.2 SHA-224 and SHA-256 Functions

Ch(x, y, z)  = (x ∧ y) ⊕ (¬x ∧ z)                    (4.2)
Maj(x, y, z) = (x ∧ y) ⊕ ( x ∧ z) ⊕ (y ∧ z)         (4.3)
S0{256}(x) = ROTR 2(x) ⊕ ROTR 13(x) ⊕ ROTR 22(x)    (4.4)
S1{256}(x) = ROTR 6(x) ⊕ ROTR 11(x) ⊕ ROTR 25(x)    (4.5)
s0{256}(x) = ROTR 7(x) ⊕ ROTR 18(x) ⊕ SHR   3(x)    (4.6)
s1{256}(x) = ROTR 17(x) ⊕ ROTR 19(x) ⊕ SHR 10(x)    (4.7)
```

Those functions are pretty easy to implement as macros. Just change the provided logical symbols into C bitwise operations:

```c
// algorithm functions
#define ROTL(x, n) ((x << n) | (x >> (w - n)))
#define ROTR(x, n) ((x >> n) | (x << (w - n)))
#define CH(x, y, z) ((x & y) ^ (~x & z))
#define MAJ(x, y, z) ((x & y) ^ (x & z) ^ (y & z))
#define S0(x) (ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22))
#define S1(x) (ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25))
#define s0(x) (ROTR(x, 7) ^ ROTR(x, 18) ^ (x >> 3))
#define s1(x) (ROTR(x, 17) ^ ROTR(x, 19) ^ (x >> 10))
```

Before we proceed, notice this quote:

>Throughout this specification, the “big-endian” convention is used when expressing 
both 32- and 64-bit words, so that within each word, the most significant bit is stored 
in the left-most bit position.

Most machines nowadays are little-endian. This means that we need to perform conversion for our algorithm to work properly. Those macros look a bit weird, but what they do is check machine endianness and swap bytes from one convention to another:

```c
//Check if the machine is big-endian
#define ENDIAN (*(uint16_t *)"\0\xff" < 0x100)

// byteswap functions for little-endian machines
#define BSWAP32(x) ((uint32_t)((((x) & 0x000000FF) << 24) | \
 (((x) & 0x0000FF00) << 8)  | \
 (((x) & 0x00FF0000) >> 8)  | \
 (((x) & 0xFF000000) >> 24)))
#define BSWAP64(x) ((uint64_t)((((x) & 0x00000000000000FFULL) << 56) | \
 (((x) & 0x000000000000FF00ULL) << 40) | \
 (((x) & 0x0000000000FF0000ULL) << 24) | \
 (((x) & 0x00000000FF000000ULL) << 8)  | \
 (((x) & 0x000000FF00000000ULL) >> 8)  | \
 (((x) & 0x0000FF0000000000ULL) >> 24) | \
 (((x) & 0x00FF000000000000ULL) >> 40) | \
 (((x) & 0xFF00000000000000ULL) >> 56)))
```

Now, let's take a look at the constants section:

```
4.2.3 SHA-384, SHA-512, SHA-512/224 and SHA-512/256 Constants

SHA-384, SHA-512, SHA-512/224 and SHA-512/256 use the same sequence of eighty constant 
64-bit words, K0 {512}, K1 {512}, ... K79 {512}. These words represent the first sixty-four bits of the 
fractional parts of the cube roots of the first eighty prime numbers. In hex, these constant words 
are (from left to right)

428a2f98 71374491 b5c0fbcf e9b5dba5 3956c25b 59f111f1 923f82a4 ab1c5ed5
d807aa98 12835b01 243185be 550c7dc3 72be5d74 80deb1fe 9bdc06a7 c19bf174
e49b69c1 efbe4786 0fc19dc6 240ca1cc 2de92c6f 4a7484aa 5cb0a9dc 76f988da
983e5152 a831c66d b00327c8 bf597fc7 c6e00bf3 d5a79147 06ca6351 14292967
27b70a85 2e1b2138 4d2c6dfc 53380d13 650a7354 766a0abb 81c2c92e 92722c85
a2bfe8a1 a81a664b c24b8b70 c76c51a3 d192e819 d6990624 f40e3585 106aa070
19a4c116 1e376c08 2748774c 34b0bcb5 391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3
748f82ee 78a5636f 84c87814 8cc70208 90befffa a4506ceb bef9a3f7 c67178f2
```

Those constants can be pretty easily implemented as a global array of constant integers:

```c
// algorithm constants
const uint32_t K[] = {
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
};
```

Let's take a look at the initial hash values:

```
5.3.3 SHA-256

For SHA-256, the initial hash value, H(0), shall consist of the following eight 32-bit words, in 
hex:

H0 = 6a09e667
H1 = bb67ae85
H2 = 3c6ef372
H3 = a54ff53a
H4 = 510e527f
H5 = 9b05688c
H6 = 1f83d9ab
H7 = 5be0cd19
```

Those can be implemented pretty easily as well:

```c
// initial hash values
const uint32_t H0[] = {
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19,
};
```

## Reading input

Let's think about how we get our input. For now, I suggest reading input from the user. Implementation is quite straightforward:

```c
// read line from standard input
int getline(uint8_t *s, uint32_t size) {
    fgets(s, size, stdin);
 *strchr(s, '\n') = 0;
    return strlen(s);
}
```

Notice the third line. We are truncating a newline character (`strchr` is used to locate a character in a string at return a pointer to it).

## Message padding

Now, let's read about preprocessing:

```
5.1.1 SHA-1, SHA-224 and SHA-256

Suppose that the length of the message, M, is l bits. Append the bit “1” to the end of the 
message, followed by k zero bits, where k is the smallest, non-negative solution to the equation 
l + 1 + k = 448 mod 512. Then append the 64-bit block that is equal to the number l expressed
using a binary representation. For example, the (8-bit ASCII) message “abc” has length 
8x3 = 24, so the message is padded with a one-bit, then 448 - (24 + 1) = 423 zero bits, and then
the message length becomes the 512-bit padded message.

5.2.1 SHA-1, SHA-224 and SHA-256
For SHA-1, SHA-224, and SHA-256, the message and its padding are parsed into N 512-bit 
blocks, M(1), M(2), ..., M(N). Since the 512 bits of the input block may be expressed as sixteen 32-
bit words, the first 32 bits of message block i are denoted M0(i), the next 32 bits are M1(i), and so 
on up to M15(i).
```

Right away, we can notice that we'll need two things:

- Message, which is an array of characters
- Message blocks of 512 bits that are used for parsing the message

Without further ado, let's implement a `context` that will hold all the necessary information for us:

```c
// message block is block with 16 x 32 byte words = 512 bit
typedef uint32_t mblock[m/8];

// context stores all necessary information for processing
typedef struct {
    uint8_t *msg; // message
 mblock  *mblocks; // message blocks
    size_t size; // message size
    size_t N; // number of message blocks
    uint32_t H[8]; // hash values
} sha256_ctx;
```

Now take a look at the message padding section. Here is what we need to do:

- Allocate a new block of memory and initialize it to zero
- Copy our message to this block
- Set the leftmost bit in byte after message to one
- Set the last 64 bits to the size of the message, in bits

To allocate new memory, we need to know the size in advance. Let's start with the size of our message. This code assumes that our message is at the `msg` field of the `ctx` pointer to context:

```c
uint64_t l = strlen(ctx->msg) * 8;
```

Now let's count the amount to zeroes that we will append to our message. We won't count 1-bit since we will take care of it separately. We will append 64 bits as the message size, which leaves us with 448 remaining bits. Given the size of the message, it's pretty easy to calculate the amount of zeroes that we will append to the message:

```c
uint32_t k = 448 - (size % 448)
```

Consider an edge case, however. Let's say that our message is exactly 448 bits. Since the message size takes 64 bits, we have no place to put our terminating 1 bit. In such a case, we have to create a new block of 512 bits between the `1` bit and the message size. Here is the scheme. The first line is an address, the second line is a value in memory, and the third line is comments. This scheme uses hexadecimal notation.

```
00 01 02 .. 01bf 01c0 01c1 .. 01ff
61 62 63 ..   63   80   00 ..   00
< message >        1bit < zeros >

--- new block
00    ..    ..    .. 01fe 01ff
00    ..    ..    ..   01   c0
< zeros >       < message size, 64bit, big-endian > 
```

Here is how it translates to code:

```c
uint32_t k = (l % 448) ? 448 - (l % 448) : m; // m = 512
```

Remember that we need to write message size in the big-endian convention. This means that if our machine is little-endian, we need to swap the bytes:

```c
uint64_t ls = ENDIAN ? l : BSWAP64(l); // swap l if machine is little-endian
```

The size of our message (in bytes) looks like this:

```c
ctx->size = (l + k + 64) / 8; // message + padding zeros + message size
```

Now let's allocate the buffer and copy our message:

```c
uint8_t *buf = calloc(ctx->size, sizeof(uint8_t));
strcpy(buf, ctx->msg);
```

Notice that we use `calloc` instead of `malloc`. This way, our memory is initialized to zeros.

`l` denotes the size of the message in bits, which is `l / 8` in bytes. We need to set the first bit of this byte to 1. Each byte has 8 bits, which means that we need to set the rightmost bit to one (which is just `1`) and shift it to (8 - 1) positions:

```
0000 0001
 <-------
1000 0000
```

```c
buf[l / 8] = 1 << (8 - 1);
```

Now we need to copy our big-endian message size `ls` to the end of the message. Since size takes 64 bits, we need to put it 64 / 8 = 8 bytes before the end:

```c
memcpy(&buf[ctx->size-8], &ls, sizeof(uint64_t));
```

Finally, update the context `msg` field to point to our buffer:

```c
ctx->msg = buf;
```

Notice that we are not calling `free` for the previous `ctx->msg` field. You might think that it will produce a memory leak. However, `ctx->msg` was not set to memory on the heap. Instead, it was set to a stack-allocated array that holds our user input. It means that this memory will be freed automatically as soon as a function that allocated this array goes out of scope.

Here is how our message padding function looks like:

```c
/* message padding */
void sha256_padding(sha256_ctx *ctx) {
    uint64_t l = strlen(ctx->msg) * 8;
    uint32_t k = (l % 448) ? 448 - (l % 448) : m;
    uint64_t ls = ENDIAN ? l : BSWAP64(l);
    ctx->size = (l + k + 64) / 8;
    printf("l = %llu, k = %u, sz = %llu\n", l, k, ctx->size);
    uint8_t *buf = calloc(ctx->size, sizeof(uint8_t));
    strcpy(buf, ctx->msg);
    buf[l / 8] = 1 << (8 - 1);
    memcpy(&buf[ctx->size-8], &ls, sizeof(uint64_t));
    ctx->msg = buf;
}
```

Notice usage of uniform integer types (like `uint32_t`). We do this because we can't make assumptions about the target machine.

## Message parsing

Now let's take care of message parsing. First, let's count how many 512-bit blocks we will need. This is pretty easy:

```c
ctx->N = ctx->size * 8 / m;
```

Remember that `N` is the number of blocks that we need, `size` is the size of the (now padded) message in bytes, and `m` is the number of bits per block.

Let's allocate new memory:

```c
ctx->mblocks = malloc(ctx->N * 16 * sizeof(uint32_t));
```

We need to allocate `N` x 16 x 4 bytes of memory. 

Notice that `ctx->mblocks` is a pointer to `mblock`, and `mblock`, in turn, is an alias for an array of 16 x 32-bit words. This means that `ctx->mblocks` is a pointer to an array, which is essentially an array of arrays (allocated contiguously on the heap). It looks like this:

```
[   <- ctx->mblocks
 [ 01 02 03 .. 10 ] <- mblock
 [ ..    ..    .. ]
 ...
]
```

Now let's fill message blocks with our message. To do that, we need to treat our message, which is an array of bytes, as an array of words, which have 4 bytes:

```
ba ad fo od de ad be ef ..
0xbaadfood  0xdeadbeef  ..
```

Let's cast our message, which is a pointer to bytes, to a pointer to words called `wrdptr`:

```c
uint32_t *wrdptr = (uint32_t *) ctx->msg;
```

Now if you try to just fill the message blocks, they will be filled with big-endian words. However, notice that our machine most likely is a little-endian. We will perform arithmetical operations on message blocks, therefore they must be converted into a convention that our computer works with:

```c
for (int i = 0; i < ctx->N; i++) {
    for (int j = 0; j < 16; j++) {
        uint32_t n = wrdptr[i * 16 + j];
        ctx->mblocks[i][j] = ENDIAN ? n : BSWAP32(n);
 }
}
```

Our outer loop iterates through message blocks (of 16 words) and our inner loop iterates through words inside of a message block. Hence, the index of the word is calculated as `i * 16 + j`. Such a word is then converted into little-endian notation if necessary.

That's it for the parsing. Here is what our function looks like:

```c
/* parse message into message blocks */
void sha256_parse(sha256_ctx *ctx) {
    ctx->N = ctx->size * 8 / m;
    ctx->mblocks = malloc(ctx->N * 16 * sizeof(uint32_t));
    uint32_t *wrdptr = (uint32_t *) ctx->msg;
    for (int i = 0; i < ctx->N; i++) {
        for (int j = 0; j < 16; j++) {
            uint32_t n = wrdptr[i * 16 + j];
            ctx->mblocks[i][j] = ENDIAN ? n : BSWAP32(n);
 }
 }
}
```

## Initialize context

Context initialization is pretty straightforward:

```c
/* initialize context */
void sha256_init(sha256_ctx *ctx) {
    memcpy(ctx->H, H0, 8 * sizeof(uint32_t));
}
```

We are just copying values from `H0` into the `H` field of our context. We do not initialize it with zero, since initialization is taken care of in another place.

## Conclusion

Phew, that was quite a lot of work. We have not started to implement the algorithm itself yet, but we are pretty much done with all preparations. In the next part, we will cover the hashing algorithm implementation.